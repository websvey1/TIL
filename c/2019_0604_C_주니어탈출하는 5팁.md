## 주니어 딱지를 떼자

### Tip 1 ) 함수가 필요한 이유를 기억하자

####  - 유형 1 

   ```c
void main(){
    int v1=1, v2=3, v3=-5, v4=-3, v5=5, v6=-4;
    result1 = v1+v2;
    result2 = v3+v4;
    result3 = v5+v6;
}
   ```

#### - 유형2

```c
int Sum(int data1, data2){
    return data1+data2;
}
void main(){
    int v1=1, v2=3, v3=-5, v4=-3, v5=5, v6=-4;
    result1 = Sum(v1,v2);
    result2 = Sum(v3,v4);
    result3 = Sum(v5,v6);
}
```

- 위와 같은 상황에서 값이 음수일 때 양수로 바꾸는 코드를 추가한다고 하면,

  유형1은 모든 식을 다 바꿔야 하지만, 유형2는 Sum함수 부분에 조건을 추가하면 된다. 코드가 길어질수록 변화에 대처할 수 있는 유연함이 유형2가 더 좋다.



### Tip 2 ) if문을 줄이자

ex ) 변수 A값이 5면 A에 2를 더한다

```c
if (A==5){
    A = A+2;
}
```

위 식의 if문을 없앤다면

```c
A = A+2 * (5 == A); // (5==A)가 거짓이라면 2*0이 되어 덧셈이 사라지고 참이라면 2*1이 되어 5에 2가 더해짐
```

```c
if (A>2){
    if (A<10) A++;
}
// 위 식과 아래 식은 같은식
if (A>2 && A<10) A++; // 단 양쪽 모두 참일 떄,
```





### Tip 3 ) if 조건문에서 조건수식을 단순화하자

```c
if ( A != 0 )  == > if (A)
if ( A==0) ==> if (!A)
if (!(A==0 && B==0)) ==> if (A!=0 || B!=0) ==> if (A || B)
```



### Tip 4 ) 메모리 정렬 방식을 알아두자

- CISC : 모든 고급 언어의 명령에 각각의 기계어가 대응되게 한 것

- RISC : 자주 사용하는 명령만 모아 프로세서를 만든 것

- 이 두 방식은 메모리 정렬 방식이 다르다는 것

  - 빅 엔디언방식 : 정보를 메모리에 저장할 때 주소가 낮은쪽에서 높은쪽으로 진행 , 시작주소 < 끝주소

    큰 자리수(변수의 상위바이트)부터 저장

    0x 12345678 => | 12 | 34 | 56 | 78|

    유닉스와 리눅스의 정렬방식, JAVA

  - 리틀 엔디언 방식 : 정보를 메모리에 저장할 때 주소가 높은쪽에서 낮은쪽으로 진행

    작은자리수(변수의 하위바이트)부터 저장

    0x 12345678 => |78 | 56 | 34 | 12 |

    윈도우의 정렬방식이다

### Tip 5 ) 형변환, 자료형이 다른 두 변수간에 값을 대입하려면?

```c
void main(){
    unsigned int a = 0x12345678, b = 0x12345678;
    unsigned char c = 0x48, d = 0x00;
    a = c;
    d = b; 
    printf("%d %d %d %d", a,b,c,d);  // a는 c값으로 바뀌었지만, d값은 120 ( 0x78 )으로 출력됌.
    // 78인 이유 = b는 | 12 | 34 | 56 | 78 | 로 되어있고 d의 1바이트 | 00 |가 | 78 | 로 바뀌기 때문
}
```


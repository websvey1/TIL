# def find(x,y):
#     dx = [-1,-1,-1, 0,0, 1,1,1] # 첫 자리를 맡으면서 퀸을 놓을수 없는 자리를 자 체크하기 위함
#     dy = [-1, 0, 1,-1,1,-1,0,1]
#     que =[]
#     que.append((x,y))
#     chk[x][y] = 1
#     while que:
#         xx,yy = que.pop(0)
#         for i in range(len(dx)):
#             nx = xx+dx[i]
#             ny = yy+dy[i]
#             if nx <0 or ny<0 or nx>=N or ny>=N: continue
#             if chk[nx][ny] ==1:continue
#             chk[nx][ny] = 1
#             que.append((nx,ny))
#
# N = 4
# data = [[0 for _ in range(N)]for _ in range(N)]
# chk = [[0] * N for _ in range(N)]
# print(chk)
# for i in range(N):
#     for j in range(N):
#         if data[i][j] ==0:
#             find(i,j)
# print(chk)

#################################################################
#####################   강  사  님  ##############################
#################################################################
def check(r,c):
    dr = [-1,-1,-1]  #아래는 검사할 필요가 없음
    dc = [-1, 0, 1]
    for i in range(3):
        for k in range(1,N):   #1배,, 2배,, 증감치의 배수 계산
            nr = r+dr[i]*k
            nc = c+dc[i]*k
            if nr<0 or nc<0 or nr>=N or nc>=N:break
            if data[nr][nc] ==1:return 0
    return 1

def DFS(n):
    global sol
    if n ==N:
        sol +=1
        return
    ############################################################
    ####################check함수를 이용 #########################
    ###########################################################
    # for i in range(N): # i = 열
    #     if check(n,i): # 퀸을 놓을 수 잇으면
    #         data[n][i] = 1 # 퀸 넣기
    #         DFS(n+1)
    #         data[n][i] = 0 # 퀸빼기

    ############################################################
    ####################check함수를 이용 #########################
    ###########################################################

    ############################################################
    ####################check 배열을 이용 #########################
    ###########################################################
    for i in range(N):
        if chk1[i]:continue #세로 방향체크
        if chk2[i+n]: continue #오른대각선 방향체크
        if chk3[(N-1)-(n-i)]: continue # 왼쪽대각 방향체크
        chk1[i] = chk2[i+n] = chk3[(N-1)-(n-i)] = 1
        DFS(n+1)
        chk1[i] = chk2[i+n] = chk3[(N-1)-(n-i)] = 0
    ############################################################
    ####################check 배열을 이용 #########################
    ###########################################################

N = 10
data = [[0 for _ in range(N)]for _ in range(N)]
sol = 0
chk1 = [0]*N
chk2 = [0]*(N*2)
chk3 = [0]*(N*2)
DFS(sol)
print(sol)

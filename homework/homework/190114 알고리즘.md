# 알고리즘 190114

```
김한욱 강사님
hanoogi@naver.com
010-5491-9784
```

---

삼성 코딩 등급

```
IM  ->  가장 기본적인 시험, for문 2개, 많으면 3개 정도의 난이도
```

```
AD -> 완전검색, 모든 경우의 수를 다 따져야 함.  ex) 서울->부산 경로를 구할때
하나하나 전부다 구해봐야함, / 재귀함수를 알아야 함.
재귀가 너무 느리면  DP(dynamic programing) 동적 계획법 해야함
```

```
PRO -> 메인함수를 주고, 매개변수를 주고 문제만 7~8장
```

```
EXP -> 2~3%만 붙여준다는 소문...
```

https://www.swexpertacademy.com/ 에서 A형이  IM등급으로 , 연습을 할 수 있음



```
스크립트 언어 -> 인터프리트 언어??
인터프리트 언어 => 한줄씩 실행하는 프로그램 언어(파이썬)
   - 장점 / 바로바로 확인 가능 , 단점 / 느려
컴파일러 => 한번에 실행 가능(C? java)
    - 장점 / 빠르다 , 단점 / 
```

## 컴파일러의 역사

- ALGOL 과 B에 이어 데니스 리치가 UNIX 운영체제를 만들기 위해 C를 만들었다.

C를 이용해 만든 객체지향 언어가 c++, java를 견제하여 MS가 만든언어가 c#이다.

- Java는 원래 이름이 oak였다.  SUN이 만들었지만 지금은 oracle로 넘어갔다.

자바는 모든프로그램에 JRE(javja running environment)가 깔려있어 어떤 환경에서도 실행.

안드로이드가 linux커널 위에 java로 만들어졌다. 아이폰은 object-c.

- python이 빅데이터 라이브러리가 잘 만들어져 있다.

- 알고리즘 입장에서 언어는 중요하지 않다, 도구일뿐 !

  

pycham 설치 !

---

----

# 배열

- 배열은 List와 같다.  index와 for를 이용한 반복문을 이용할 줄 알아야한다.

  메소드 사용하지 않고 직접 구현하며 수업할 예정

- 선택정렬, 삽입정렬, 버블정렬이 쉽고 느리다.

---

### 알고리즘 

- 정확한동작, 적은 작업량, 적은 메모리사용량, 단순성, 최적성

- 빅오(O) 표기법

  ```
  O(n)이면 for문이 1개(1부터 n까지)
  
  ```

  - 이진탐색은 O(log)를 사용한다

  - 순차탐색은 O(n)을 사용

  - 퀵정렬 merge정렬  heep 정렬은 O(nlog n)

  - 선택 버블 삽입정렬은 O(n^2) / for가 2개

  - 모든  쌍 최단경로 알고리즘O(n^3) / 각 도시(ex - 서울 대전 광주 대구 등 모든 도시간의 경로)

    P 문제 , 다항식 쓰면 풀 수 있는 문제

    ---

    NP문제, n이 커질수록 시간이 너무오래걸린다...

  - 부분집합은 O(2^n) 사용

  - TSP 는 O(n!) 사용 / 도시 1, 2, 3, 4, 5가 있고 모든 경로를 탐색해본다.

    ```
     택배아저씨가 택배 20개를 돌리는데, 모든 경우의수를탐색하고 최적의 알고리즘을 찾으려면
    3000년이 넘게 걸린다. 그래서 경험적으로(대략) 알게 된 최적의 경로를 이용하는데 나중에 알고리즘을 이런 방식으로 접근해야한다.
    ```

  \

  ```
  연습문제 풀이(IM문제 3시간짜리)
  1. 모든 경우의 수를 다 구해보자
  2. 최대 낙차를 구한다. A=8, B=7 ....
  3. A[1]부터 하나하나 구해보자, 아래에 몇개가 있는지 . (8-아래에 있는 개수)
  4. for문이 2개가 들어간다고 한다.(왜?)
  ```

  ```
  연습문제 2 풀이 
  내 생각으로는 트피블은 if .count == 3 조건으로 빼고,  나머지는 n n+1 n+2가 맞는지 확인.
  강사님 = 6가지 모두 구한다(6! = 720) 완전검색 ! // 내가 생각한건 greedy , 한방에 맞추기
  ```

  ```python
  a = {1, 2, 3} 이 주어졌다면 . / 
  1 - 2 - 3
    - 3 - 2
  2 - 1 - 3
    - 3 - 1
  3 - 1 - 2
    - 2 - 1  등 총 6개(3!)를 만들 수 있다.
  (1) for를 활용한 풀이
    - for i in a:
       for j in a:
        for k in a   등 for가 길어진다...
        == >  순열.py 참조
  ```

  ---

  # 탐욕알고리즘

  ```
  거스름돈 예시
  800원을 거슬러 주는데, 이때 최적의 알고리즘 = 500원 , 100원 * 3 // 단위가 큰 동전부터 !
  1) 해선택 = 단위가큰 동전부터 / 500원을 거스러 줌
  2) 실행 가능성 검사 = 또 500원을 주려하니 1000원이 되어 +200원이 over, 단위를 100원짜리로내림
  3) 해 검사 = 더 드려도 안되고 덜드려도 안되기때문에 정확히 맞춰야함, 안맞는다면 또 1로 가서 다시
              동전의 단위를 내림(10원으로)
  ```



call by value : 값이 바뀌지 않는 것, list를 제외한 나머지 / 원본이 아니라 복사본을 건네줌. stack에 저장 

call by reference : list처럼 리턴값이 바뀌는 것 // list는 포인터를 통해 메모리의 주소를 참조한다. heap에 저장